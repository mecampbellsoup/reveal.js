<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Idris: It's Like Haskell But Cooler</title>

		<meta name="description" content="An Introduction to Type Theory in Idris">
		<meta name="author" content="Matt Campbell">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Idris: Like Haskell, Only Cooler.</h1>
					<br>
					<h3>An Introduction to Type Theory in Idris</h3>
					<p>
						<small>Brought to you by <a href="https://github.com/mecampbellsoup">Matt Campbell</a> / <a href="http://twitter.com/mecampbellsoup">@mecampbellsoup</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>Some quick examples...</h2>
						<p>Let's prime your brains, shall we?</p>
					</section>

					<section data-markdown>
        	<script type="text/template">
						## Data Types
						Data types are declared in a similar way to Haskell data types, with a similar syntax. Natural numbers and lists, for example, can be declared as follows:

						```haskell
						data Nat = Z | S Nat

						Idris> S Z
						1 : Nat

						Idris> S 4
						5 : Nat

						Idris> S 5.0
						-- ... what's going to happen here?

						data List a = Nil | (::) a (List a)
						```
						P.S.: `Idris>` indicates we're in the Idris REPL. Starting it by running `idris <file>` from the CLI starts a server (by default) on port 4294... so we can do some cool stuff with that.
					</script>
					</section>

					<section data-markdown>
        	<script type="text/template">
						## Basic Addition
						Functions are implemented by pattern matching, again using a similar syntax to Haskell. The main difference is that IDRIS requires type declarations for all functions, using a single colon : (rather than Haskell’s double colon ::).
						```haskell
						-- Unary addition
						plus : Nat -> Nat -> Nat
						plus Z     y = y
						plus (S k) y = S (plus k y)

						Idris> plus (S (S Z)) (S (S Z))
						4 : Nat
						```
					</script>
					</section>

					<section data-markdown>
        	<script type="text/template">
						## Basic Multiplication...
						<small>...doesn't feel so basic anymore :(</small>
						<p class="fragment current-visible">Basically, multiplication is implemented by recursively calling `plus` `(S k)` times on `y`...</p>

						```haskell
						−− Unary multiplication
						mult : Nat -> Nat -> Nat
						mult Z     y = Z
						mult (S k) y = plus y (mult k y)
						```

						<p class="fragment current-visible">So, `(3 * 4)` is represented as:</p><br>
						<p class="fragment current-visible">`plus 4 (plus 4 ( 4 ))`</p>

						<div class="fragment current-visible">
							<pre><code class="haskell">Idris> mult (S (S (S Z))) (plus (S (S Z)) (S (S Z)))
12 : Nat</code></pre>
						</div>
					</script>
					</section>
				</section>

				<section>
					<section data-markdown>
	      	<script type="text/template">
						## so far, so good!
						Good work everybody. So far, we've seen that Idris and Haskell really aren't so different.
						So what's all the fuss about?
						![](http://www.superiorsilkscreen.com/360-404-thickbox/i-plan-on-living-forever-so-far-so-good.jpg)
					</script>
					</section>
				</section>

				<section>
					<section data-markdown>
	      	<script type="text/template">
						## Dependent Types
						Dependent types allow types to be predicated on values. IDRIS uses full-spectrum dependent types, meaning that there is no restriction on which values may appear in types.

						![](https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcTqmVJLLL9HS9ECV0AK1Bu9d8ATNqrRhCyTXglDRITJvWm0xbu6)
					</script>
					</section>

					<section data-markdown>
	      	<script type="text/template">
						## Vectorz
						![](http://www.ctwatch.org/quarterly/figures/12/ma-figure1.gif)
					</script>
					</section>

					<section data-markdown>
	      	<script type="text/template">
	      		### ... wutz uh vektur?
						Vectors are lists which carry their size in the type. Basically, vectors are polymorphic "lists with length" and are a standard example of a dependent type. In IDRIS, we declare vectors as follows:
						```haskell
data Vect : Nat -> Type -> Type where
    Nil  : Vect Z a
    (::) : a -> Vect k a -> Vect (S k) a
						```
						<br>
						We say that `Vect` is _indexed_ over `Nat` and _parameterised_ by `Type`.
					</script>
					</section>

					<section data-markdown>
	      	<script type="text/template">
						## Adding 2 Vects
						This is really an exercise in defining a function on dependent types. For example, `append`, well, appends two Vects:
						```haskell
						total
						append : Vect n a -> Vect m a -> Vect (n + m) a
						append Nil       ys = ys
						append (x :: xs) ys = x :: (append xs ys)
						```
						<br>
						Since the precise types of the input vectors depend on a value, it is possible to be certain at compile-time that the resulting vector will be have exactly `(n + m)` elements of type `a`.

						<br><small class="fragment highlight-blue">P.S.: The word `total` invokes the totality checker which will report an error if the marked function doesn't cover all possible cases.</small>
					</script>
					</section>

					<section data-markdown>
	      	<script type="text/template">
						## Pairwise Addition
						Here's a good example of the "extra security" offered by dependent types in Idris...
						```haskell
						total
						vAdd : Num a => Vect a n -> Vect a n -> Vect a n
						vAdd [] [] = []
						vAdd (x :: xs) (y :: ys) = x + y :: vAdd xs ys
						```
						<br>
						We can check the totality of our function, but it isn't necessary, really - we know the input vectors to `vAdd` will have identical lengths (i.e. either empty, or non-empty)
					</script>
					</section>

					<section data-markdown>
	      	<script type="text/template">
						<h2>Pairwise Addition (Cont.)</h2><br>
						<p class="fragment roll-in">Let's use Edwin Brady's <a href="http://edwinb.wordpress.com/2013/10/28/interactive-idris-editing-with-vim/" "vim idris repl">vim Idris REPL plugin</a> to re-construct this function.</p><br>
						<pre><code class="haskell">vAdd : Num a => Vect a n -> Vect a n -> Vect a n
						</code></pre>
						<br>
						<p class="fragment roll-in">`Num a` signifies that the type `a` belongs to the type class `Num`.</p>
						<p class="fragment roll-in">Note that this function still typechecks successfully as `total`, even though there is no case matching `Nil` in one vector and a number in the other.<span class="fragment roll-in"> ... <em><strong>Why?</strong></em></span></p>
						<p class="fragment roll-in">Since both vectors must have, ensured via the type system, exactly the same length we can be sure at compile time that this is a case that will not occur.</p>
						<p class="fragment roll-in">Hence it does not need to be mentioned for the function to be `total`.</p>
					</script>
					</section>
				</section>

				<section>
					<section data-markdown>
	      	<script type="text/template">
						## Finite Sets
						Finite sets, as the name suggests, are sets with a finite number of elements.
						```haskell
						data Fin : Nat -> Type where
							fZ : Fin (S k)
							fS : Fin k -> Fin (S k)
						```
					</script>
					</section>

					<section data-markdown data-background="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png">
	      	<script type="text/template">
						A useful application of the `Fin` family is to represent bounded natural numbers. Since the first `n` natural numbers form a finite set of `n` elements, we can treat `Fin n` as the set of natural numbers bounded by `n`.

						Let's write a function which looks up an element in a `Vect`, by a bounded index given as a `Fin n`, and using our Idris vim plugin:
					</script>
					</section>

					<section data-markdown data-background="#9900FF">
	      	<script type="text/template">
	      	## a better (read: safer) way to get a vector elem<br><br>
	      	```haskell
index : Fin n -> Vect n a -> a
	      	```
	      	<br>
	      	<p class="fragment highlight-green grow">Let's take it to the vim!</p>
					</script>
					</section>

					<section data-markdown data-background="#007777">
	      	<script type="text/template">
	      	## a better (read: safer) way to get a vector elem<br><br>
	      	```haskell
index : Fin n -> Vect n a -> a
index fZ     (x :: xs) = x
index (fS k) (x :: xs) = index k xs
	      	```
	      	<br>
	      	The location is bounded by the length of the vector (`n` in each case), so there is no need for a run-time bounds check. The type checker guarantees that the location is no larger than the length of the vector.
					</script>
					</section>
				</section>

				<section>
					<section data-markdown>
		    		![](https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcQ6c3UyqrWsjnkQm0AHiHG_TIHDDvzdGmdmmJThNm6z_-SEz63lAQ)
		    		## ... but why dependent types?
	      	</section>

	      	<section data-markdown>
	      	<script type="text/template">
	      		## Precise Types
	      		<pre>
<code class="haskell">sort : List Int -> List Int</code>
<code class="haskell">sort : Vect Int n -> Vect Int n</code>
<code class="haskell">sort : (xs : Vect Int n) -> (ys : Vect Int n ** Permutation xs ys)</code>
	      		</pre>
	      		But clearly, the trade-off is complex implementations...
      		</script>
	      	</section>
				</section>

				<section data-markdown>
					## sources & further reading :)
					1. http://eb.host.cs.st-andrews.ac.uk/talks/idris-cph-lec1.pdf
					1. http://en.wikipedia.org/wiki/Idris_(programming_language)
					1. http://edwinb.wordpress.com/category/idris/
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
